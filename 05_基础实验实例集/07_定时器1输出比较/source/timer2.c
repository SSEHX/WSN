/*******************************************************************************
 * 文件名称：timer2.c
 * 功    能：CC253x系列片上系统基础实验--- 定时器1输出比较(发生匹配时产生中断)
 * 描    述：使用定时器1的输出比较功能，控制LED1(P1.0)。每0.5s切换一次LED3(绿色)
 *           的亮灭状态。当发生匹配时，P1.0(即定时器1的通道2)的输出发生切换，这
 *           样就控制了LED1(P1.0)的亮/灭。同时，在发生匹配时，还将产生中断，在
 *           中断服务程序中切换LED3（P1.3）的亮灭。
 * 硬件连接： LED与CC253x的硬件连接关系如下：
 *                LED                          CC253x  
 *               LED1（D3）                       P1.0
 *               LED2（D4）                       P1.1
 *               LED3（D5）                       P1.3
 *               LED4（D6）                       P1.4
                  SW1                             P1.2
 * 作    者：HJL
 * 日    期：2012-8-14
 ******************************************************************************/
/* 包含头文件 */
/********************************************************************/
#include "ioCC2530.h"  // 引用头文件,包含对CC2530的寄存器、中断向量等的定义
/********************************************************************/
//定义led灯端口：p1.3, p1.4：

#define LED1 P1_0     // P1_0定义为P1.0
#define LED2 P1_1     // P1_1定义为P1.1
#define LED3 P1_3     // P1_3定义为P1.3
#define LED4 P1_4     // P1_4定义为P1.4
#define SW1  P1_2     // P1_2定义为SW1

/*********************************************************************
 * 函数名称：init
 * 功    能：初始化系统IO,定时器T1控制状态寄存器
 * 入口参数：无
 * 出口参数：无
 * 返 回 值：无
 ********************************************************************/
void init()
{ 
   P1SEL &= ~0x08;     // 设置P1.3为普通IO口
   P1DIR |= 0x08 ;    // 设置P1.3为输出
   LED3 = 0;       // P1.3输出高电平点亮其所控制的LED3(黄色)
   
   PERCFG |= 0x40;  // 配置Timer1的外设I/O使用位置2  
   P1SEL |= 0x01;  //配置P1.0为定时器1的片内外设I/O 
   P1DIR |= 0x01 ;    // 设置P1.0为输出  
  
  T1CCTL2 |= ((0x06 << 3) |  /* 发生匹配时通道2的输出电平0，= T1CC0时置1*/
              (0x01 << 2));  /* 通道2工作在输出比较模式(匹配模式) */ 
  /*  配置定时器1的16位计数器的计数频率
       Timer Tick    分频    定时器1的计数频率     要获得0.5s的延时，应设置T1CC2
                                                   中的比较值(匹配值)为
       16MHz         /128    125KHz                62500   */
  
  /* 给T1CC2写入模的值(周期0.5S) */
  T1CC0L = 62500 & 0xFF;             // 把62500的低8位写入T1CC0L
  T1CC0H = ((62500 & 0xFF00) >> 8);  // 把62500的高8位写入T1CC0H  T1CC0周期
  
  /* 给T1CC2写入比较值(匹配值)12500 */
  T1CC2L =12500 & 0xFF;              
  T1CC2H = ((12500 & 0xFF00) >> 8);  // 占空比 
  
  T1CTL = 0x0e;  // 配置128分频，模工作模式，并开始启动  
  TIMIF &= ~0x40;  //不产生定时器1的溢出中断
                   //定时器1的通道2的中断使能T1CCTL2.IM默认使能
  IEN1 |= 0x02;    //使能定时器1的中断  
  EA = 1;          //使能全局中断
  
}

/*********************************************************************
 * 函数名称：T1_ISR
 * 功    能：定时器1中断服务函数
 * 入口参数：无
 * 出口参数：无
 * 返 回 值：无
 ********************************************************************/
#pragma vector=T1_VECTOR
__interrupt void T1_ISR(void)
{
   EA = 0;           // 关闭全局中断  
   if((T1STAT & 0x04) == 0x04) //若产生的是通道2中断 
   {  
        LED3=!LED3;       //切换LED3(绿色)的亮灭状态
        T1STAT &= ~0x04;   // 清零通道2中断标志 
     }  
    EA = 1;          // 使能全局中断
}  

/*********************************************************************
 * 函数名称：main
 * 功    能：main函数入口
 * 入口参数：无
 * 出口参数：无
 * 返 回 值：无
 ********************************************************************/
void main(void)
{
  init();
  while(1);
}