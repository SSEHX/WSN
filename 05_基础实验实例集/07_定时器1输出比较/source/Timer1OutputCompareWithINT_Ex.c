/*******************************************************************************
 * 文件名称：Timer1OutputCompareWithINT_Ex.c
 * 功    能：CC253x系列片上系统基础实验--- 定时器1输出比较(发生匹配时产生中断)
 * 描    述：使用定时器1的输出比较功能，控制LED6(蓝色)闪烁。每0.5s切换一次LED6(蓝色)
 *           的亮灭状态。当发生匹配时，P1.0(即定时器1的通道2)的输出发生切换，这
 *           样就控制了LED6(蓝色)的亮/灭。同时，在发生匹配时，还将产生中断，我们在
 *           中断服务程序中切换LED4(黄色)的亮灭。
 * 实验硬件：SK-SmartRF05EB
 * 作    者：MENG
 * 日    期：2011-4-15
 ******************************************************************************/


/* 包含头文件 */
/********************************************************************/
#include "ioCC2530.h"    // CC2530的头文件，包含对CC2530的寄存器、中断向量等的定义
/********************************************************************/


/*********************************************************************
 * 函数名称：T1_ISR
 * 功    能：定时器1中断服务函数
 * 入口参数：无
 * 出口参数：无
 * 返 回 值：无
 ********************************************************************/
#pragma vector=T1_VECTOR
__interrupt void T1_ISR(void)
{
  EA = 0;           // 关闭全局中断
 
  /* 
     由於定时器1具有多个中断事件，除非用户非常明确进入
     该函数是由於哪个具体的中断事件造成的，否则用户应
     加以判断 
  */
  /* 若产生的是通道2中断 */
  if((T1STAT & 0x04) == 0x04)
  {  
    T1STAT &= ~0x04;  // 清零通道2中断标志
    
    /* 切换LED3(黄色)的亮灭状态 */
    P1_4 = !P1_4;
  
  }
  
  EA = 1;          // 使能全局中断    
}  


/*********************************************************************
 * 函数名称：main
 * 功    能：main函数入口
 * 入口参数：无
 * 出口参数：无
 * 返 回 值：无
 ********************************************************************/
void main(void)
{
  /*
     由於CC253x系列片上系统上电复位后，所有21个数字I/O均默认为具有
     上拉的通用输入I/O，因此本实验只需要改变作为LED3(黄色)控制信号的
     P1.4方向为输出即可。
     在用户的实际应用开发中，我们建议用户采用如下步骤来配置数字I/O：
         1. 设置数字I/O为通用I/O
         2. 设置通用I/O的方向
         3. 若通用I/O的方向被配置为输入，可配置上拉/下拉/三态模式
         4. 若通用I/O的方向被配置为输出，可设置其输出高/低电平
   */
  /* 配置P1.4的方向为输出 */
  P1DIR |= 0x10;  // 0x10 = 0B00010000

  P1_4 = 0;       // P1.4输出高电平点亮其所控制的LED3(黄色)   
  
  /* 配置Timer1的外设I/O使用位置2 */
  PERCFG |= 0x40;
  
  /* 配置P1.0为定时器1的片内外设I/O */
  P1SEL |= 0x01;
  
  /* P2SEL.PRI1P1采用上电复位后的默认值，即P1.0第一优先作为定时器1的通道2 */
  
  /* 定时器1的通道2配置 */
  T1CCTL2 |= ((0x06 << 3) |  /* 发生匹配时通道2的输出电平0，= T1CC0时置1*/
              (0x01 << 2));  /* 通道2工作在输出比较模式(匹配模式) */
  
  
  /* 定时器1的中断设置 */
  /* 不产生定时器1的溢出中断 */
  TIMIF &= ~0x40;  
  /* 定时器1的通道2的中断使能T1CCTL2.IM在上电复位默认为使能，此处不用再使能*/
  /* 使能定时器1的中断 */
  IEN1 |= (0x01 << 1);
  /* 使能全局中断 */
  EA = 1; 
  
  /*
     配置定时器1的16位计数器的计数频率
       Timer Tick    分频    定时器1的计数频率     要获得0.5s的延时，应设置T1CC2
                                                   中的比较值(匹配值)为
       16MHz         /128    125KHz                62500
  */ 
  /* 此处添加对CLKCONCMD.TICKSPD进行相应设置的代码
     本实验采用上电复位后默认的16MHz Timer Tick，因
     此无需对CLKCONCMD.TICKSPD进行设置。
   */
  /* 给T1CC2写入比较值(匹配值)62500 */
  T1CC0L = 62500 & 0xFF;             // 把62500的低8位写入T1CC2L
  T1CC0H = ((62500 & 0xFF00) >> 8);  // 把62500的高8位写入T1CC2H  T1CC0周期
  
  T1CC2L = 32500 & 0xFF;             // 
  T1CC2H = ((32500 & 0xFF00) >> 8);  // 占空比  
   /* 配置128分频，自由计数器工作模式，并开始启动*/ 
  //T1CTL = 0x0D;
   /* 配置128分频，工作模模式，并开始启动*/ 
  T1CTL = 0x0e;

  while(1);
}