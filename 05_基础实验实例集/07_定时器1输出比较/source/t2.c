/*******************************************************************************
  * 文件名称：t2.c
 * 功    能：CC253x系列片上系统基础实验 ---按键控制开关
 * 描    述：使用CC253x系列片上系统的数字I/O作为检测按键是否按下，
          若点按SW1，则LED灯切换至下一个LED灯闪烁
 * 硬件连接： LED与CC253x的硬件连接关系如下：
 *                LED                          CC253x  
 *               LED1（D3）                       P1.0
 *               LED2（D4）                       P1.1
 *               LED3（D5）                       P1.3
 *               LED4（D6）                       P1.4
                  SW1                             P1.2
 * 作    者：HJL
 * 日    期：2012-8-14
 ******************************************************************************/
/* 包含头文件 */
/********************************************************************/
#include "ioCC2530.h"  // 引用头文件,包含对CC2530的寄存器、中断向量等的定义
/********************************************************************/
//定义led灯端口：p1.3, p1.4：

#define LED1 P1_0     // P1_0定义为P1.0
#define LED2 P1_1     // P1_1定义为P1.1
#define LED3 P1_3     // P1_3定义为P1.3
#define LED4 P1_4     // P1_4定义为P1.4
#define SW1  P1_2     // P1_2定义为SW1


/* 定义枚举类型 */
/********************************************************************/
enum STATE{START_STATE,RUN_STATE,STOP_STATE};  // 定义秒表的状态
enum STATE state = START_STATE;  // 初始化应用状态为开始

/*********************************************************************
* 函数名称：delay
 * 功    能：软件延时
 * 入口参数：无
 * 出口参数：无
 * 返 回 值：无
 ********************************************************************/
void delay(unsigned int time)
{ unsigned int i;
  unsigned char j;
  for(i = 0; i < time; i++)
  {  for(j = 0; j < 240; j++)
      {   asm("NOP");    // asm是内嵌汇编，nop是空操作,执行一个指令周期
          asm("NOP");
          asm("NOP");
       }  
   }  
}

/*********************************************************************
 * 函数名称：init
 * 功    能：初始化系统IO,定时器T1控制状态寄存器
 * 入口参数：无
 * 出口参数：无
 * 返 回 值：无
 ********************************************************************/
void init()
{    P1SEL &= ~0x0D;     // 设置LED1、SW1为普通IO口
     P1DIR |= 0x09 ;    // 设置LED1为输出
     P1DIR &= ~0X04;	//Sw1按键在 P1.2,设定为输入
     LED1 = 0;         //灭 LED
     LED3 = 1;         //亮 LED
   
     
     PICTL &= ~0x02;  //配置P1口的中断边沿为上升沿产生中断
     P1IEN |= 0x04;  //使能P1.2中断
     IEN2 |= 0x10;  //使能P1口中断
    

  /* 配置定时器1的16位计数器的计数频率
     由於采用正计数/倒计数器工作模式，希望一个正计数/倒计数过程
     (从0x0000~T1CC0，再从T1CC0~0x0000)的时长为0.5s，那么正计数时长和倒计数时长
     都应为0.25s，通过计算可知，有多种设置可以满足，以下为本实验采用的设置：
       Timer Tick    分频    定时器1的计数频率   T1CC0的值  一个正计数时长或
                                                            一个倒计数时长    
       32MHz         /128    250KHz              62500      0.25s  */  
   
     CLKCONCMD &= ~0x38;   // 设置Timer Tick为32MHz       
     T1CC0L = 62500 & 0xFF;             // 把62500的低8位写入T1CC0L
     T1CC0H = ((62500 & 0xFF00) >> 8);  // 把62500的高8位写入T1CC0H 
    
     EA = 1;   //使能全局中断
}


/*********************************************************************
 * 函数名称：EINT_ISR
 * 功    能：外部中断服务函数
 * 入口参数：无
 * 出口参数：无
 * 返 回 值：无
 ********************************************************************/
#pragma vector=P1INT_VECTOR
__interrupt void EINT_ISR(void)
{
    EA = 0;           // 关闭全局中断
   /* 若是P1.2产生的中断 */
    if(P1IFG & 0x04)
    { 
        /* 等待用户释放按键，并消抖 */
       while(SW1 == 0);    //低电平有效
       delay(10);
       while(SW1 == 0);  

      /* 若当前状态为"开始"状体，则进入"运行"状态*/
       if(state == START_STATE)
        {
           state = RUN_STATE;  // 更新应用状态标志变量
      
           T1STAT &= ~0x20;  // 清零溢出标志 (T1STAT.OVFIF)
         /* 此处添加设置TIMIF.OVFIM位(定时器1中断屏蔽)为1的代码 
            本实验采用上电复位后默认的设置，即TIMIF.OVFIM=1
            因此无需对TIMIF.OVFIM位再进行设置。         */     
           LED3=0;  //进入运行状态
           T1CTL = 0x0F;  //配置128分频，正计数/倒计数器工作模式     
           IEN1 |=0X02;  //定时器1中断使能           
        }
       
       /* 若当前状态为"运行"状态，则进入"停止"状体 */
       else if(state == RUN_STATE)
           {
                state = STOP_STATE;  // 更新应用状态标志变量
               /* 禁止定时器1 */
                 T1CTL &= ~0x03;  // 停止定时器1   
                 T1CNTL = 0x00;   // 清零定时器1计数器
                 T1CNTH = 0x00;   // 清零定时器1计数器
                 IEN1 &= ~0x02;  //禁止定时器1的中断 
            }
      
       /* 若当前状态为"停止"状态，则进入"开始"状体 */
       else if(state == STOP_STATE)
       {
          state = START_STATE;  // 更新应用状态标志变量 
          LED3=1;  //进入"开始"状态
       }
        
       /* 清除中断标志 */
        P1IFG &= ~0x04;   // 清除P1.2中断标志
        P0IF &= ~0x08;  // 清除P1口中断标志
    }
    EA = 1;          // 使能全局中断    
 }


/*********************************************************************
 * 功    能：定时器T1中断服务子程序
 ********************************************************************/
#pragma vector = T1_VECTOR //中断服务子程序
__interrupt void T1_ISR(void) 
 { 
   LED1 = !LED1; 
   T1IF=0;   //清T1的中断请求   
}


/*********************************************************************
 * 函数名称：main
 * 功    能：main函数入口
 * 入口参数：无
 * 出口参数：无
 * 返 回 值：无
 ********************************************************************/
void main(void)
{  
   init();   //调用初始化函数
   while(1)  ; 
 
}


