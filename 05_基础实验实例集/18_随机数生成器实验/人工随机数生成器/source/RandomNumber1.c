/*******************************************************************************
 * 文件名称：RandomNumber1.c
 * 功    能：CC253x系列片上系统基础实验--- 随机数发生器(人为设定不同的种子值)
 * 描    述：本实验使用CC253x系列片上系统的片内随机数发生器，人为设定不同的种子
 *           值以产生不同的伪随机序列，在PC串口助手上显示。
 * * 作    者：HJL
 * 日    期：2012-9-11
 ******************************************************************************/


/* 包含头文件 */
/********************************************************************/
#include "ioCC2530.h"    // CC2530的头文件，包含对CC2530的寄存器、中断向量等的定义
#include "stdio.h"       // C语言标准输入/输出库的头文件
/********************************************************************/


/* 定义枚举类型 */
/********************************************************************/
enum SYSCLK_SRC{XOSC_32MHz,RC_16MHz};      // 定义系统时钟源(主时钟源)枚举类型
/*********************************************************************/

/*********************************************************************
* 函数名称：delay
 * 功    能：软件延时
 * 入口参数：无
 * 出口参数：无
 * 返 回 值：无
 ********************************************************************/
void delay(unsigned int time)
{ unsigned int i;
  unsigned char j;
  for(i = 0; i < time; i++)
  {  for(j = 0; j < 240; j++)
      {   asm("NOP");    // asm是内嵌汇编，nop是空操作,执行一个指令周期
          asm("NOP");
          asm("NOP");
       }  
   }  
}

/*********************************************************************
 * 函数名称：SystemClockSourceSelect
 * 功    能：选择系统时钟源(主时钟源)
 * 入口参数：source
 *             XOSC_32MHz  32MHz晶体振荡器
 *             RC_16MHz    16MHz RC振荡器
 * 出口参数：无
 * 返 回 值：无
 ********************************************************************/
void SystemClockSourceSelect(enum SYSCLK_SRC source)
{
  unsigned char clkconcmd,clkconsta;
   if(source == RC_16MHz)
  {             
    CLKCONCMD &= 0x80;
    CLKCONCMD |= 0x49;    //01001001   
  }
  else if(source == XOSC_32MHz)
  {
    CLKCONCMD &= 0x80;
  }  
  
  /* 等待所选择的系统时钟源(主时钟源)稳定 */
  clkconcmd = CLKCONCMD;             // 读取时钟控制寄存器CLKCONCMD
  do
  {
    clkconsta = CLKCONSTA;           // 读取时钟状态寄存器CLKCONSTA
  } while(clkconsta != clkconcmd);  // 直到选择的系统时钟源(主时钟源)已经稳定 
}



/*********************************************************************
 * 函数名称：InitUART0
 * 功    能：UART0初始化
 *           P0.2  RX                  
 *           P0.3  TX
 *           波特率：57600
 *           数据位：8
 *           停止位：1
 *           奇偶校验：无
 * 入口参数：无
 * 出口参数：无
 * 返 回 值：无
 ********************************************************************/
void initUART0(void)
{
  /* 片内外设引脚位置采用上电复位默认值，即PERCFG寄存器采用默认值 */
    PERCFG = 0x00;	//位置 1 P0 口     
    /* UART0相关引脚初始化 
       P0.2――RX，      P0.3――TX      P0.4――CT，      P0.5――RT   */     
    P0SEL = 0x3c;	//P0 用作串口, P0.2、P0.3、P0.4、P0.5作为片内外设I/O  
    
    /*波特率57600,8位数据位，1位停止位,无奇偶校验****/
    U0BAUD = 216; 
    U0GCR = 10;  //32M晶振
  
  /* USART模式选择 */
    U0CSR |= 0x80;  // UART模式
    U0UCR |= 0x80;  // 进行USART清除
   
   UTX0IF = 0;  // 清零UART0 TX中断标志
   EA = 1;   //使能全局中断
}


/*********************************************************************
 * 函数名称：UART0SendByte
 * 功    能：UART0发送一个字节
 * 入口参数：c
 * 出口参数：无
 * 返 回 值：无
 ********************************************************************/
void UART0SendByte(unsigned char c)
{
  U0DBUF = c;       // 将要发送的1字节数据写入U0DBUF(串口 0 收发缓冲器)  
  while (!UTX0IF);  // 等待TX中断标志，即U0DBUF就绪
  UTX0IF = 0;       // 清零TX中断标志 
}


/*********************************************************************
 * 函数名称：UART0SendString
 * 功    能：UART0发送一个字符串
 * 入口参数：str
 * 出口参数：无
 * 返 回 值：无
 ********************************************************************/
void UART0SendString(char *str)
{
  while(1)
  {
    if(*str == '\0') break;  // 遇到结束符，退出
    UART0SendByte(*str++);   // 发送一字节
  } 
}


/*********************************************************************
 * 函数名称：init
 * 功    能：初始化系统IO
 * 入口参数：无
 * 出口参数：无
 * 返 回 值：无
 ********************************************************************/
void initIO(void)
{   P1SEL &= ~0x11;     // 设置LED1、LED4为普通IO口
    P1DIR |= 0x011 ;    // 设置LED1在P1.0为输出    
    P1_0= 0;            // LED灭
    P1_4= 0;
}


/*********************************************************************
 * 函数名称：main
 * 功    能：main函数入口
 * 入口参数：无
 * 出口参数：无
 * 返 回 值：无
 ********************************************************************/
void main(void)
{
  char s[31];
  unsigned short dataSQ;
  unsigned char i;
  
  
  //P1DIR |= 0x11;  // 0x11 = 0B00010001
  initIO();   //初始化IO
  SystemClockSourceSelect(XOSC_32MHz);  // 选择32MHz晶体振荡器作为系统时钟源(主时钟源)
  
  initUART0();   //初始化UART0

  /* 在串口助手上显示相关信息 */
  UART0SendString("CC253x 随机数产生...\r\n");
  delay(1000);
    
  while(1)
  { 
    UART0SendString("以0x6688为种子值(有效种子值)，产生伪随机序列...\r\n");
    /* 写入种子值 */
    RNDL = 0x66;  // 写入种子值的高8位
    RNDL = 0x88;  // 写入种子值的低8位
    
    /* 在串口助手上显示种子值 */    
    sprintf(s,"0x%04X  \r\n",0x6688);
    UART0SendString(s);
    delay(1000);
    
    /* 产生相应的伪随机序列,只产生前10个数据 */
    for(i=0;i<5;i++)
    {
      /* 启动"13次等效移位"操作 */
      ADCCON1 |= (0x01 << 2);
      
      /* 等待操作完成 */
      while((ADCCON1 & 0x04) != 0); 
      
      /* 读取产生的数据 */
      dataSQ = RNDH;                    // 读取产生的数据的高8位      
      dataSQ = (dataSQ << 8) | RNDL;    // 读取产生的数据的低8位，
                                        // 然后与高8位合并成为16位数据
      
      /* 在串口助手上显示 */
      sprintf(s,"0x%04X  \r\n",dataSQ);  // 将数据转换为要显示的字符串   
      UART0SendString(s);
    }
    
    P1_0 = 1; // 种子值有效,LED1灯亮
    P1_4 = 0;
 
    delay(60000);  // 延时
    delay(60000); 
    UART0SendString("以0x0000为种子值(无效种子值)，产生伪随机序列...\r\n");
     /* 注意：以0x0000为种子值，LFSR状态一直为全零 */
    /* 写入种子值 */
    RNDL = 0x00;  // 写入种子值的高8位
    RNDL = 0x00;  // 写入种子值的低8位
    /* 在串口助手上上显示种子值 */
    sprintf(s,"0x%04X  \r\n",0x0000);
    UART0SendString(s);
    delay(1000);
    
    /* 产生相应的伪随机序列,只产生前2个数据 */
    for(i=0;i<2;i++)
    {
      /* 启动"13次等效移位"操作 */
      ADCCON1 |= (0x01 << 2);
      
      /* 等待操作完成 */
      while((ADCCON1 & 0x04) != 0); 
      
      /* 读取产生的数据 */
      dataSQ = RNDH;                    // 读取产生的数据的高8位      
      dataSQ = (dataSQ << 8) | RNDL;    // 读取产生的数据的低8位，
                                        // 然后与高8位合并成为16位数据
      
       /* 在串口助手上显示 */
      sprintf(s,"0x%04X  \r\n",dataSQ);  // 将数据转换为要显示的字符串   
      UART0SendString((char*)s);
    }
    
    P1_4 = 1; // 种子值无效,LED4灯亮
    P1_0 = 0;
      
    delay(60000);  // 延时
    delay(60000); 
    UART0SendString("以0x8003为种子值(无效种子值)，产生伪随机序列...\r\n");
     /* 注意：以0x8003为种子值，LFSR状态一直为0x8003 */
    /* 写入种子值 */
    RNDL = 0x80;  // 写入种子值的高8位
    RNDL = 0x03;  // 写入种子值的低8位
    /* 在串口助手上显示种子值 */
    sprintf(s,"0x%04X   \r\n",0x8003);
    UART0SendString(s); 
    delay(1000);
    
    /* 产生相应的伪随机序列,只产生前2个数据 */
    for(i=0;i<2;i++)
    {
      /* 启动"13次等效移位"操作 */
      ADCCON1 |= (0x01 << 2);
      
      /* 等待操作完成 */
      while((ADCCON1 & 0x04) != 0); 
      
      /* 读取产生的数据 */
      dataSQ = RNDH;                    // 读取产生的数据的高8位      
      dataSQ = (dataSQ << 8) | RNDL;    // 读取产生的数据的低8位，
                                        // 然后与高8位合并成为16位数据
      
      /* 在串口助手上显示 */
      sprintf(s,"0x%04X \r\n",dataSQ);  // 将数据转换为要显示的字符串   
      UART0SendString(s);
    }
     
    P1_4 = 1; // 种子值无效，,LED4灯亮
    P1_0 = 0;
    
    delay(60000);  // 延时 
    delay(60000);  

   }
}